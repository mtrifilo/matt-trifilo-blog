---
title: Learning to Learn to Code - 00 Introduction
date: 2020-10-01
description: Learning to Learn to Code - 00 Introduction
tags:
  - Learn to code
---

## The Earth Says Hello

This post is the first in a series on how to learn to code effectively, and avoid many of the pitfalls I'd experienced on my own journey.

If you're learning to code, you're about to survey the current landscape of software engineering, how different (but similar) complex technologies tie together, and how you can solve almost any problem while shipping a software project. We'll get low level enough to ship a single page application, but this will mostly be a guided tour of software development in general, along with links to high-quality resources for leveling up. 

## But Why?

Why not jump into more code tutorials? Why learn to learn to code? Who needs context around complex topics?

I did. Context matters a lot as it turned out. 

One of the hardest parts of learning to code is filling in the knowledge gaps between topics without mentors. You can learn HTML, CSS, JavaScript, and React. You can learn Node, Express, and MongoDB. You can learn Golang, C, and Assembly. Congrats to you! But what if you decide to build a single-page application with persisted data that can scale? Where do you begin? How do you decide what libraries to use? How do you know when to even use a library? We'll get to that. The challenge with learning these technologies separately is there's really no good way to learn how to tie them together without actually doing it. There are plenty of tutorials on how to build an app using the multiple technologies mentioned, but what happens when you begin building your own apps with your own requirements? This gap is what I'm going to focus on, while discussing the relationships between your favorite technologies and tools, and how to discover what you need to fill these gaps on your own. This can apply to projects, interviews, and even your startup idea.  

Learning higher-level topics like the histories of programming languages and tools, their initial design objectives versus current usage, and how they've evolved over the years may seem like a waste of time when you just want to build apps. Trust me on this. Wasting weeks on a solution that is hyped up in the industry, but not necessary for what you're trying to do, is a much bigger waste of time. Knowing where the languages and tools came from and why can help you properly wield them, and make good decisions based on your objective--not industry hype that may not be relevant to your goals. 

Say it with me: "My pet-share app does NOT need block chain."

## What's ahead?



